import { StripRustCodeComments } from "../../../components/strip-rust-code-comments";

# Request a Proof

The [Boundless Market SDK](/developers/tooling/sdk) allows developers to build and submit requests to the Boundless protocol; the SDK has sensible defaults, designed to make sending ~95% of requests straightforward.

Therefore, this page is split into two sections:

  - The first section, [Sending A Request](#sending-a-request), shows the quickest and easiest way to request a proof using these *sensible defaults*, without any additional configuration.
  - The second section, [Request Configuration](#request-configuration), covers all available configuration options for the 5% of requests that require fine-tuning.

## Sending a Request

:::note[Source Code]
All code you see below can be found at: [apps/src/main.rs](https://github.com/boundless-xyz/boundless/blob/main/examples/counter/apps/src/main.rs)
:::

### 0. Getting Started

If you want to follow along locally, start by running:

```bash
git clone https://github.com/boundless-xyz/boundless.git
git checkout release-0.8
cd boundless/examples/counter && cargo build && forge build
```

### 1. Setting environment variables

:::tip[Parsing environment variables]
We recommend using [clap](https://crates.io/crates/clap) to parse these environment variables, as seen in [apps/L37-52](https://github.com/boundless-xyz/boundless/blob/cdc2435b6119a009c2cc73dc227a250bee7594fc/examples/counter/apps/src/main.rs#L37-L52).
:::

#### Blockchain

Since we are submitting requests onchain, we will need private key for a wallet with sufficient funds on Sepolia, and a working RPC URL:

```bash
export RPC_URL="https://..."
export PRIVATE_KEY="abcdef..."
```

:::tip[Alchemy]
We recommend using Alchemy for your RPC URL during testing; their free tier is more than enough to test requesting a proof.
:::

#### Storage Provider

To make a program, and its inputs, accessible to provers, they need to be hosted on a public HTTP server. We recommend using IPFS for storage, particularly via [Pinata](https://pinata.cloud), as their free tier comfortably covers most Boundless use cases.

Before submitting a request, you'll need to:

- Sign up for an account with [Pinata](https://pinata.cloud).
- Generate an API key following their [documentation](https://docs.pinata.cloud/account-management/api-keys).
- Copy the JWT token and set it as the `PINATA_JWT` environment variable:

```bash
export PINATA_JWT="abcdef..."
```

### 2. Build the Boundless Client

<StripRustCodeComments>
```rust
# use alloy::signers::local::PrivateKeySigner;
# use boundless_market::{Client, storage::storage_provider_from_env};
# async fn create_boundless_client(
# rpc_url: url::Url,
# private_key: PrivateKeySigner) -> Result<(), Box<dyn std::error::Error>> {
let client = Client::builder()
  .with_rpc_url(args.rpc_url)
  .with_private_key(args.private_key)
  .with_storage_provider(&args.storage_config)?
  .build()
  .await?;
# Ok(())
# }
```
</StripRustCodeComments>

### 3. Create and Submit a Proof Request

<StripRustCodeComments>
```rust
# use anyhow::Result;
# use boundless_market::{Client};
# async fn create_proof_request(
# client: Client,
# program: &'static [u8],
# input: &[u8]) -> Result<()> {
// Create a request using new_request
let request = client.new_request().with_program(ECHO_ELF).with_stdin(echo_message.as_bytes());

// Submit the request directly
let (request_id, expires_at) = client.submit_onchain(request).await?;
# Ok(())
# }
```
</StripRustCodeComments>

### 4. Retrieve the Proof

Once submitted, you can keep track of the request using:

```rust
// Wait for the request to be fulfilled. The market will return the journal and seal.
tracing::info!("Waiting for request {:x} to be fulfilled", request_id);
let (journal, seal) = client
    .wait_for_request_fulfillment(
        request_id,
        Duration::from_secs(5), // check every 5 seconds
        expires_at,
    )
    .await?;
tracing::info!("Request {:x} fulfilled", request_id);
```

This will store the `journal` and `seal` from the Boundless market, together they represent the public outputs of your guest and the proof itself, respectively. You can [use a proof in your application](/developers/tutorials/use) to access the power of verifiable compute using Boundless.

## Request Configuration

### Storage Providers

The Boundless Market SDK automatically configures the storage provider based on environment variables; it supports both IPFS and S3 for storage.

#### IPFS

For example, if you set the following:

```bash
export PINATA_JWT="abcdef"...
```

then when you use `.with_storage_provider()`:

<StripRustCodeComments>
```rust
# use alloy::signers::local::PrivateKeySigner;
# use boundless_market::{Client, storage::storage_provider_from_env};
# async fn create_boundless_client(
# rpc_url: url::Url,
# private_key: PrivateKeySigner) -> Result<(), Box<dyn std::error::Error>> {
let client = Client::builder()
  .with_rpc_url(args.rpc_url)
  .with_private_key(args.private_key)
  .with_storage_provider(&args.storage_config)? // [!code hl] // [!code focus]
  .build()
  .await?;
# Ok(())
# }
```
</StripRustCodeComments>

*IPFS* is set automatically to the storage provider, and your JWT will be used to upload programs/inputs via Pinata's gateway.

#### S3

To use S3 as your storage provider, you need to set the following environment variables:

```bash
export S3_ACCESS_KEY="abcdef..."
export S3_SECRET_KEY="abcdef..."
export S3_BUCKET="bucket-name..."
export S3_URL="https://bucket-url..."
export AWS_REGION="us-east-1"
Once these are set, this will automatically use the specified [AWS S3 bucket](https://docs.aws.amazon.com/AmazonS3/latest/userguide/creating-buckets-s3.html) for storage of programs and inputs.
```

#### No Storage Provider

A perfectly valid option for `StorageProvider` is `None`; if you don't set any relevant environment variables for IPFS/S3, you are allowed to skip th storage provider when building and submitting a request via the `client`. This means you will have to pass through a valid URL for the program and inputs. For the inputs, you can also pass them inline if they are small enough.

### Uploading Programs

Provers must be able to access your guest program via a publicly accessible URL; the Boundless Market SDK allows you to directly upload your program in a few different ways.

#### Manually

<StripRustCodeComments>
```rust
# use boundless_market::{Client, storage::storage_provider_from_env};
# async fn upload_program(program: &[u8]) -> Result<(), Box<dyn std::error::Error>> {
# let client = Client::builder()
#   .with_storage_provider(Some(storage_provider_from_env()?))
#   .build()
#   .await?;
let program_url = client.upload_program(program).await?;
# Ok(())
# }
```
</StripRustCodeComments>

After which, you'd create a request with:

```rust
let request = client.new_request()
  .with_program_url(&program_url)
  .with_input_url(&input_url);
```

#### Automagically

If you are working in a monorepo, it is also possible to call `with_program`... TODO


### Uploading Inputs

:::tip[*Rather not have inputs publicly available?**]
When working with trusted provers, you can store inputs in *Amazon S3* and restrict access via AWS S3's permission management - [Sensitive Inputs tutorial](/developers/tutorials/sensitive-inputs).
:::

To execute and run proving, the prover requires the inputs of the program.
Similar to the program executable, the program inputs are uploaded to the same storage provider. This can be done manually like so:

<StripRustCodeComments>
```rust
# use boundless_market::{Client, storage::storage_provider_from_env};
# async fn upload_input(input_bytes: Vec<u8>) -> Result<(), Box<dyn std::error::Error>> {
# let client = Client::builder()
#   .with_storage_provider(Some(storage_provider_from_env()?))
#   .build()
#   .await?;
let input_url = client.upload_input(&input_bytes).await?;
# Ok(())
# }
```
</StripRustCodeComments>

or if we look back at the counter example, we can see that the inputs are included directly into the request:

<StripRustCodeComments>
```rust
# use anyhow::Result;
# use boundless_market::{Client};
# async fn create_proof_request(
# client: Client,
# program: &'static [u8],
# input: &[u8]) -> Result<()> {
// Create a request using new_request
let request = client.new_request().with_program(ECHO_ELF).with_stdin(echo_message.as_bytes()); // [!code hl] // [!code focus]

// Submit the request directly
let (request_id, expires_at) = client.submit_onchain(request).await?;
# Ok(())
# }
```
</StripRustCodeComments>

When submitting requests onchain, this will cost more gas if the inputs are large.
The offchain order-stream service also places limits on the size of in-line input.

### Onchain vs Offchain

The Boundless protocol allows you to submit requests both onchain and offchain.

For this tutorial, we will concern ourselves with onchain requests only. For onchain requests, Boundless uses a set of [smart contracts](/developers/smart-contracts/reference); these contracts are a central hub for requests *and* proofs. Our aim to is submit a request for a proof so that provers can pick up the request and deliver our proof.


### Offer Parameters

TODO:

- OfferParams:

```rust showLineNumbers
  .with_offer(
    OfferParams::builder()
      // The market uses a reverse Dutch auction mechanism to match requests with provers.
      // Each request has a price range that a prover can bid on.
      .min_price(parse_ether("0.001")?)
      .max_price(parse_ether("0.002")?)
      // The timeout is the maximum number of blocks the request can stay
      // unfulfilled in the market before it expires. If a prover locks in
      // the request and does not fulfill it before the timeout, the prover can be
      // slashed.
      .timeout(1000)
      .lock_timeout(500)
      .ramp_up_period(100)
  );
```

- input modalities i.e. inline as bytes
- storage provider, perhaps S3 env vars to set
- `with_program(ELF)` directly (link out to quick start).
